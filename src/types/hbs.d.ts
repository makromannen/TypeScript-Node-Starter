/** Declaration file generated by dts-gen */

export class SafeString {
    constructor(string: any);

    toHTML(): any;

    toString(): any;

}

export const cache: {
};

export function compile(str: any): any;

export function create(handlebars: any): any;

export function localsAsTemplateData(app: any): any;

export function registerAsyncHelper(name: any, fn: any, ...args: any[]): any;

export function registerHelper(...args: any[]): void;

export function registerPartial(...args: any[]): void;

export function registerPartials(directory: any, done: any): any;

// export namespace SafeString {
//     namespace prototype {
//         function toHTML(): any;
//
//         function toString(): any;
//
//         namespace toHTML {
//             const prototype: {
//             };
//
//         }
//
//         namespace toString {
//             const prototype: {
//             };
//
//         }
//
//     }
//
// }

export namespace Utils {
    function appendContextPath(contextPath: any, id: any): any;

    function blockParams(params: any, ids: any): any;

    function createFrame(object: any): any;

    function escapeExpression(string: any): any;

    function extend(obj: any, ...args: any[]): any;

    function indexOf(array: any, value: any): any;

    function isArray(p0: any): any;

    function isEmpty(value: any): any;

    function isFunction(value: any): any;

    function toString(): any;

    namespace appendContextPath {
        const prototype: {
        };

    }

    namespace blockParams {
        const prototype: {
        };

    }

    namespace createFrame {
        const prototype: {
        };

    }

    namespace escapeExpression {
        const prototype: {
        };

    }

    namespace extend {
        const prototype: {
        };

    }

    namespace indexOf {
        const prototype: {
        };

    }

    namespace isEmpty {
        const prototype: {
        };

    }

    namespace isFunction {
        const prototype: {
        };

    }

}

export namespace compile {
    const prototype: {
    };

}

export namespace create {
    const prototype: {
    };

}

export namespace handlebars {
    class Compiler {
        constructor();

        BlockStatement(block: any): void;

        BooleanLiteral(bool: any): void;

        CommentStatement(): void;

        ContentStatement(content: any): void;

        Decorator(decorator: any): void;

        DecoratorBlock(decorator: any): void;

        Hash(hash: any): void;

        MustacheStatement(mustache: any): void;

        NullLiteral(): void;

        NumberLiteral(number: any): void;

        PartialBlockStatement(partialBlock: any): void;

        PartialStatement(partial: any): void;

        PathExpression(path: any): void;

        Program(program: any): any;

        StringLiteral(string: any): void;

        SubExpression(sexpr: any): void;

        UndefinedLiteral(): void;

        accept(node: any): any;

        addDepth(depth: any): void;

        ambiguousSexpr(sexpr: any, program: any, inverse: any): void;

        blockParamIndex(name: any): any;

        classifySexpr(sexpr: any): any;

        compile(program: any, options: any): any;

        compileProgram(program: any): any;

        compiler(): void;

        equals(other: any): any;

        helperSexpr(sexpr: any, program: any, inverse: any): void;

        opcode(name: any, ...args: any[]): void;

        pushParam(val: any): void;

        pushParams(params: any): void;

        setupFullMustacheParams(sexpr: any, program: any, inverse: any, omitEmpty: any): any;

        simpleSexpr(sexpr: any): void;

    }

    class HandlebarsEnvironment {
        constructor(helpers: any, partials: any, decorators: any);

        log(level: any, ...args: any[]): void;

        registerDecorator(name: any, fn: any): void;

        registerHelper(name: any, fn: any): void;

        registerPartial(name: any, partial: any): void;

        unregisterDecorator(name: any): void;

        unregisterHelper(name: any): void;

        unregisterPartial(name: any): void;

    }

    class JavaScriptCompiler {
        constructor();

        aliasable(name: any): any;

        ambiguousBlockValue(): void;

        append(): any;

        appendContent(content: any): void;

        appendEscaped(): void;

        appendToBuffer(source: any, location: any, explicit: any): any;

        assignToHash(key: any): void;

        blockValue(name: any): void;

        compile(environment: any, options: any, context: any, asObject: any): any;

        compileChildren(environment: any, options: any): void;

        compiler(): void;

        compilerInfo(): any;

        contextName(context: any): any;

        createFunctionContext(asObject: any): any;

        depthedLookup(name: any): any;

        emptyHash(omitEmpty: any): void;

        flushInline(): void;

        getContext(depth: any): void;

        incrStack(): any;

        initializeBuffer(): any;

        invokeAmbiguous(name: any, helperCall: any): void;

        invokeHelper(paramSize: any, name: any, isSimple: any): void;

        invokeKnownHelper(paramSize: any, name: any): void;

        invokePartial(isDynamic: any, name: any, indent: any): void;

        isInline(): any;

        lookupBlockParam(blockParamId: any, parts: any): void;

        lookupData(depth: any, parts: any, strict: any): void;

        lookupOnContext(parts: any, falsy: any, strict: any, scoped: any): void;

        matchExistingProgram(child: any): any;

        mergeSource(varDeclarations: any): any;

        nameLookup(parent: any, name: any): any;

        objectLiteral(obj: any): any;

        popHash(): void;

        popStack(wrapped: any): any;

        preamble(): void;

        programExpression(guid: any): any;

        push(expr: any): any;

        pushContext(): void;

        pushHash(): void;

        pushId(type: any, name: any, child: any): void;

        pushLiteral(value: any): void;

        pushProgram(guid: any): void;

        pushSource(source: any): void;

        pushStackLiteral(item: any): void;

        pushString(string: any): void;

        pushStringParam(string: any, type: any): void;

        quotedString(str: any): any;

        registerDecorator(paramSize: any, name: any): void;

        replaceStack(callback: any): void;

        resolvePath(type: any, parts: any, i: any, falsy: any, strict: any): any;

        resolvePossibleLambda(): void;

        setupHelper(paramSize: any, name: any, blockHelper: any): any;

        setupHelperArgs(helper: any, paramSize: any, params: any, useRegister: any): any;

        setupParams(helper: any, paramSize: any, params: any): any;

        topStack(): any;

        topStackName(): any;

        useRegister(name: any): void;

        static RESERVED_WORDS: {
            abstract: boolean;
            await: boolean;
            boolean: boolean;
            break: boolean;
            byte: boolean;
            case: boolean;
            catch: boolean;
            char: boolean;
            class: boolean;
            const: boolean;
            continue: boolean;
            debugger: boolean;
            default: boolean;
            delete: boolean;
            do: boolean;
            double: boolean;
            else: boolean;
            enum: boolean;
            export: boolean;
            extends: boolean;
            false: boolean;
            final: boolean;
            finally: boolean;
            float: boolean;
            for: boolean;
            function: boolean;
            goto: boolean;
            if: boolean;
            implements: boolean;
            import: boolean;
            in: boolean;
            instanceof: boolean;
            int: boolean;
            interface: boolean;
            let: boolean;
            long: boolean;
            native: boolean;
            new: boolean;
            null: boolean;
            package: boolean;
            private: boolean;
            protected: boolean;
            public: boolean;
            return: boolean;
            short: boolean;
            static: boolean;
            super: boolean;
            switch: boolean;
            synchronized: boolean;
            this: boolean;
            throw: boolean;
            throws: boolean;
            transient: boolean;
            true: boolean;
            try: boolean;
            typeof: boolean;
            var: boolean;
            void: boolean;
            volatile: boolean;
            while: boolean;
            with: boolean;
            yield: boolean;
        };

        // static isValidJavaScriptVariableName(name: any): any;

    }

    class SafeString {
        constructor(string: any);

        toHTML(): any;

        toString(): any;

    }

    const AST: {
        helpers: {
            helperExpression: any;
            scopedId: any;
            simpleId: any;
        };
    };

    const COMPILER_REVISION: number;

    const REVISION_CHANGES: {
        "1": string;
        "2": string;
        "3": string;
        "4": string;
        "5": string;
        "6": string;
        "7": string;
    };

    const VERSION: string;

    const partials: {
    };

    function Exception(message: any, node: any): void;

    function compile(input: any, options: any): any;

    function createFrame(object: any): any;

    function escapeExpression(string: any): any;

    function log(level: any, ...args: any[]): void;

    function parse(input: any, options: any): any;

    function precompile(input: any, options: any): any;

    function registerDecorator(name: any, fn: any): void;

    function registerHelper(name: any, fn: any): void;

    function registerPartial(name: any, partial: any): void;

    function template(spec: any): any;

    function unregisterDecorator(name: any): void;

    function unregisterHelper(name: any): void;

    function unregisterPartial(name: any): void;

    namespace Compiler {
        // namespace prototype {
        //     // Circular reference from hbs.handlebars.Compiler.prototype
        //     const compiler: any;
        //
        //     const guid: number;
        //
        //     function BlockStatement(block: any): void;
        //
        //     function BooleanLiteral(bool: any): void;
        //
        //     function CommentStatement(): void;
        //
        //     function ContentStatement(content: any): void;
        //
        //     function Decorator(decorator: any): void;
        //
        //     function DecoratorBlock(decorator: any): void;
        //
        //     function Hash(hash: any): void;
        //
        //     function MustacheStatement(mustache: any): void;
        //
        //     function NullLiteral(): void;
        //
        //     function NumberLiteral(number: any): void;
        //
        //     function PartialBlockStatement(partialBlock: any): void;
        //
        //     function PartialStatement(partial: any): void;
        //
        //     function PathExpression(path: any): void;
        //
        //     function Program(program: any): any;
        //
        //     function StringLiteral(string: any): void;
        //
        //     function SubExpression(sexpr: any): void;
        //
        //     function UndefinedLiteral(): void;
        //
        //     function accept(node: any): any;
        //
        //     function addDepth(depth: any): void;
        //
        //     function ambiguousSexpr(sexpr: any, program: any, inverse: any): void;
        //
        //     function blockParamIndex(name: any): any;
        //
        //     function classifySexpr(sexpr: any): any;
        //
        //     function compile(program: any, options: any): any;
        //
        //     function compileProgram(program: any): any;
        //
        //     function equals(other: any): any;
        //
        //     function helperSexpr(sexpr: any, program: any, inverse: any): void;
        //
        //     function opcode(name: any, ...args: any[]): void;
        //
        //     function pushParam(val: any): void;
        //
        //     function pushParams(params: any): void;
        //
        //     function setupFullMustacheParams(sexpr: any, program: any, inverse: any, omitEmpty: any): any;
        //
        //     function simpleSexpr(sexpr: any): void;
        //
        //     namespace BlockStatement {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.BlockStatement
        //         const prototype: any;
        //
        //     }
        //
        //     namespace BooleanLiteral {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.BooleanLiteral
        //         const prototype: any;
        //
        //     }
        //
        //     namespace CommentStatement {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.CommentStatement
        //         const prototype: any;
        //
        //     }
        //
        //     namespace ContentStatement {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.ContentStatement
        //         const prototype: any;
        //
        //     }
        //
        //     namespace Decorator {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.Decorator
        //         const prototype: any;
        //
        //     }
        //
        //     namespace DecoratorBlock {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.DecoratorBlock
        //         const prototype: any;
        //
        //     }
        //
        //     namespace Hash {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.Hash
        //         const prototype: any;
        //
        //     }
        //
        //     namespace MustacheStatement {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.MustacheStatement
        //         const prototype: any;
        //
        //     }
        //
        //     namespace NullLiteral {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.NullLiteral
        //         const prototype: any;
        //
        //     }
        //
        //     namespace NumberLiteral {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.NumberLiteral
        //         const prototype: any;
        //
        //     }
        //
        //     namespace PartialBlockStatement {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.PartialBlockStatement
        //         const prototype: any;
        //
        //     }
        //
        //     namespace PartialStatement {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.PartialStatement
        //         const prototype: any;
        //
        //     }
        //
        //     namespace PathExpression {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.PathExpression
        //         const prototype: any;
        //
        //     }
        //
        //     namespace Program {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.Program
        //         const prototype: any;
        //
        //     }
        //
        //     namespace StringLiteral {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.StringLiteral
        //         const prototype: any;
        //
        //     }
        //
        //     namespace SubExpression {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.SubExpression
        //         const prototype: any;
        //
        //     }
        //
        //     namespace UndefinedLiteral {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.UndefinedLiteral
        //         const prototype: any;
        //
        //     }
        //
        //     namespace accept {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.accept
        //         const prototype: any;
        //
        //     }
        //
        //     namespace addDepth {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.addDepth
        //         const prototype: any;
        //
        //     }
        //
        //     namespace ambiguousSexpr {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.ambiguousSexpr
        //         const prototype: any;
        //
        //     }
        //
        //     namespace blockParamIndex {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.blockParamIndex
        //         const prototype: any;
        //
        //     }
        //
        //     namespace classifySexpr {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.classifySexpr
        //         const prototype: any;
        //
        //     }
        //
        //     namespace compile {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.compile
        //         const prototype: any;
        //
        //     }
        //
        //     namespace compileProgram {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.compileProgram
        //         const prototype: any;
        //
        //     }
        //
        //     namespace equals {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.equals
        //         const prototype: any;
        //
        //     }
        //
        //     namespace helperSexpr {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.helperSexpr
        //         const prototype: any;
        //
        //     }
        //
        //     namespace opcode {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.opcode
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushParam {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.pushParam
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushParams {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.pushParams
        //         const prototype: any;
        //
        //     }
        //
        //     namespace setupFullMustacheParams {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.setupFullMustacheParams
        //         const prototype: any;
        //
        //     }
        //
        //     namespace simpleSexpr {
        //         // Too-deep object hierarchy from hbs.handlebars.Compiler.prototype.simpleSexpr
        //         const prototype: any;
        //
        //     }
        //
        // }

    }

    namespace Exception {
        namespace prototype {
            const message: string;

            const name: string;

            const stack: string;

            function toString(): any;

        }

    }

    namespace HandlebarsEnvironment {
        // namespace prototype {
        //     function log(level: any, ...args: any[]): void;
        //
        //     function registerDecorator(name: any, fn: any): void;
        //
        //     function registerHelper(name: any, fn: any): void;
        //
        //     function registerPartial(name: any, partial: any): void;
        //
        //     function unregisterDecorator(name: any): void;
        //
        //     function unregisterHelper(name: any): void;
        //
        //     function unregisterPartial(name: any): void;
        //
        //     namespace log {
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.log
        //         const prototype: any;
        //
        //     }
        //
        //     namespace logger {
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.logger
        //         const level: any;
        //
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.logger
        //         const log: any;
        //
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.logger
        //         const lookupLevel: any;
        //
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.logger
        //         const methodMap: any;
        //
        //     }
        //
        //     namespace registerDecorator {
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.registerDecorator
        //         const prototype: any;
        //
        //     }
        //
        //     namespace registerHelper {
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.registerHelper
        //         const prototype: any;
        //
        //     }
        //
        //     namespace registerPartial {
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.registerPartial
        //         const prototype: any;
        //
        //     }
        //
        //     namespace unregisterDecorator {
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.unregisterDecorator
        //         const prototype: any;
        //
        //     }
        //
        //     namespace unregisterHelper {
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.unregisterHelper
        //         const prototype: any;
        //
        //     }
        //
        //     namespace unregisterPartial {
        //         // Too-deep object hierarchy from hbs.handlebars.HandlebarsEnvironment.prototype.unregisterPartial
        //         const prototype: any;
        //
        //     }
        //
        // }

    }

    namespace JavaScriptCompiler {
        namespace isValidJavaScriptVariableName {
            // const prototype: {
            // };

        }

        // namespace prototype {
        //     // Circular reference from hbs.handlebars.JavaScriptCompiler.prototype
        //     const compiler: any;
        //
        //     function aliasable(name: any): any;
        //
        //     function ambiguousBlockValue(): void;
        //
        //     function append(): any;
        //
        //     function appendContent(content: any): void;
        //
        //     function appendEscaped(): void;
        //
        //     function appendToBuffer(source: any, location: any, explicit: any): any;
        //
        //     function assignToHash(key: any): void;
        //
        //     function blockValue(name: any): void;
        //
        //     function compile(environment: any, options: any, context: any, asObject: any): any;
        //
        //     function compileChildren(environment: any, options: any): void;
        //
        //     function compilerInfo(): any;
        //
        //     function contextName(context: any): any;
        //
        //     function createFunctionContext(asObject: any): any;
        //
        //     function depthedLookup(name: any): any;
        //
        //     function emptyHash(omitEmpty: any): void;
        //
        //     function flushInline(): void;
        //
        //     function getContext(depth: any): void;
        //
        //     function incrStack(): any;
        //
        //     function initializeBuffer(): any;
        //
        //     function invokeAmbiguous(name: any, helperCall: any): void;
        //
        //     function invokeHelper(paramSize: any, name: any, isSimple: any): void;
        //
        //     function invokeKnownHelper(paramSize: any, name: any): void;
        //
        //     function invokePartial(isDynamic: any, name: any, indent: any): void;
        //
        //     function isInline(): any;
        //
        //     function lookupBlockParam(blockParamId: any, parts: any): void;
        //
        //     function lookupData(depth: any, parts: any, strict: any): void;
        //
        //     function lookupOnContext(parts: any, falsy: any, strict: any, scoped: any): void;
        //
        //     function matchExistingProgram(child: any): any;
        //
        //     function mergeSource(varDeclarations: any): any;
        //
        //     function nameLookup(parent: any, name: any): any;
        //
        //     function objectLiteral(obj: any): any;
        //
        //     function popHash(): void;
        //
        //     function popStack(wrapped: any): any;
        //
        //     function preamble(): void;
        //
        //     function programExpression(guid: any): any;
        //
        //     function push(expr: any): any;
        //
        //     function pushContext(): void;
        //
        //     function pushHash(): void;
        //
        //     function pushId(type: any, name: any, child: any): void;
        //
        //     function pushLiteral(value: any): void;
        //
        //     function pushProgram(guid: any): void;
        //
        //     function pushSource(source: any): void;
        //
        //     function pushStackLiteral(item: any): void;
        //
        //     function pushString(string: any): void;
        //
        //     function pushStringParam(string: any, type: any): void;
        //
        //     function quotedString(str: any): any;
        //
        //     function registerDecorator(paramSize: any, name: any): void;
        //
        //     function replaceStack(callback: any): void;
        //
        //     function resolvePath(type: any, parts: any, i: any, falsy: any, strict: any): any;
        //
        //     function resolvePossibleLambda(): void;
        //
        //     function setupHelper(paramSize: any, name: any, blockHelper: any): any;
        //
        //     function setupHelperArgs(helper: any, paramSize: any, params: any, useRegister: any): any;
        //
        //     function setupParams(helper: any, paramSize: any, params: any): any;
        //
        //     function topStack(): any;
        //
        //     function topStackName(): any;
        //
        //     function useRegister(name: any): void;
        //
        //     namespace aliasable {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.aliasable
        //         const prototype: any;
        //
        //     }
        //
        //     namespace ambiguousBlockValue {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.ambiguousBlockValue
        //         const prototype: any;
        //
        //     }
        //
        //     namespace append {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.append
        //         const prototype: any;
        //
        //     }
        //
        //     namespace appendContent {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.appendContent
        //         const prototype: any;
        //
        //     }
        //
        //     namespace appendEscaped {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.appendEscaped
        //         const prototype: any;
        //
        //     }
        //
        //     namespace appendToBuffer {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.appendToBuffer
        //         const prototype: any;
        //
        //     }
        //
        //     namespace assignToHash {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.assignToHash
        //         const prototype: any;
        //
        //     }
        //
        //     namespace blockValue {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.blockValue
        //         const prototype: any;
        //
        //     }
        //
        //     namespace compile {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.compile
        //         const prototype: any;
        //
        //     }
        //
        //     namespace compileChildren {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.compileChildren
        //         const prototype: any;
        //
        //     }
        //
        //     namespace compilerInfo {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.compilerInfo
        //         const prototype: any;
        //
        //     }
        //
        //     namespace contextName {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.contextName
        //         const prototype: any;
        //
        //     }
        //
        //     namespace createFunctionContext {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.createFunctionContext
        //         const prototype: any;
        //
        //     }
        //
        //     namespace depthedLookup {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.depthedLookup
        //         const prototype: any;
        //
        //     }
        //
        //     namespace emptyHash {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.emptyHash
        //         const prototype: any;
        //
        //     }
        //
        //     namespace flushInline {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.flushInline
        //         const prototype: any;
        //
        //     }
        //
        //     namespace getContext {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.getContext
        //         const prototype: any;
        //
        //     }
        //
        //     namespace incrStack {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.incrStack
        //         const prototype: any;
        //
        //     }
        //
        //     namespace initializeBuffer {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.initializeBuffer
        //         const prototype: any;
        //
        //     }
        //
        //     namespace invokeAmbiguous {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.invokeAmbiguous
        //         const prototype: any;
        //
        //     }
        //
        //     namespace invokeHelper {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.invokeHelper
        //         const prototype: any;
        //
        //     }
        //
        //     namespace invokeKnownHelper {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.invokeKnownHelper
        //         const prototype: any;
        //
        //     }
        //
        //     namespace invokePartial {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.invokePartial
        //         const prototype: any;
        //
        //     }
        //
        //     namespace isInline {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.isInline
        //         const prototype: any;
        //
        //     }
        //
        //     namespace lookupBlockParam {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.lookupBlockParam
        //         const prototype: any;
        //
        //     }
        //
        //     namespace lookupData {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.lookupData
        //         const prototype: any;
        //
        //     }
        //
        //     namespace lookupOnContext {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.lookupOnContext
        //         const prototype: any;
        //
        //     }
        //
        //     namespace matchExistingProgram {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.matchExistingProgram
        //         const prototype: any;
        //
        //     }
        //
        //     namespace mergeSource {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.mergeSource
        //         const prototype: any;
        //
        //     }
        //
        //     namespace nameLookup {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.nameLookup
        //         const prototype: any;
        //
        //     }
        //
        //     namespace objectLiteral {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.objectLiteral
        //         const prototype: any;
        //
        //     }
        //
        //     namespace popHash {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.popHash
        //         const prototype: any;
        //
        //     }
        //
        //     namespace popStack {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.popStack
        //         const prototype: any;
        //
        //     }
        //
        //     namespace preamble {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.preamble
        //         const prototype: any;
        //
        //     }
        //
        //     namespace programExpression {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.programExpression
        //         const prototype: any;
        //
        //     }
        //
        //     namespace push {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.push
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushContext {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.pushContext
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushHash {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.pushHash
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushId {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.pushId
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushLiteral {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.pushLiteral
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushProgram {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.pushProgram
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushSource {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.pushSource
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushStackLiteral {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.pushStackLiteral
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushString {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.pushString
        //         const prototype: any;
        //
        //     }
        //
        //     namespace pushStringParam {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.pushStringParam
        //         const prototype: any;
        //
        //     }
        //
        //     namespace quotedString {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.quotedString
        //         const prototype: any;
        //
        //     }
        //
        //     namespace registerDecorator {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.registerDecorator
        //         const prototype: any;
        //
        //     }
        //
        //     namespace replaceStack {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.replaceStack
        //         const prototype: any;
        //
        //     }
        //
        //     namespace resolvePath {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.resolvePath
        //         const prototype: any;
        //
        //     }
        //
        //     namespace resolvePossibleLambda {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.resolvePossibleLambda
        //         const prototype: any;
        //
        //     }
        //
        //     namespace setupHelper {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.setupHelper
        //         const prototype: any;
        //
        //     }
        //
        //     namespace setupHelperArgs {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.setupHelperArgs
        //         const prototype: any;
        //
        //     }
        //
        //     namespace setupParams {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.setupParams
        //         const prototype: any;
        //
        //     }
        //
        //     namespace topStack {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.topStack
        //         const prototype: any;
        //
        //     }
        //
        //     namespace topStackName {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.topStackName
        //         const prototype: any;
        //
        //     }
        //
        //     namespace useRegister {
        //         // Too-deep object hierarchy from hbs.handlebars.JavaScriptCompiler.prototype.useRegister
        //         const prototype: any;
        //
        //     }
        //
        // }

    }

    namespace Parser {
        class Parser {
            constructor();

            Parser(): void;

            parse(input: any): any;

            parseError(str: any, hash: any): void;

            performAction(yytext: any, yyleng: any, yylineno: any, yy: any, yystate: any, $$: any, _$: any): any;

            trace(): void;

        }

        const defaultActions: {
            "102": number[];
            "105": number[];
            "111": number[];
            "112": number[];
            "117": number[];
            "120": number[];
            "123": number[];
            "124": number[];
            "136": number[];
            "137": number[];
            "4": number[];
            "55": number[];
            "57": number[];
            "61": number[];
            "74": number[];
            "83": number[];
            "87": number[];
            "91": number[];
        };

        const productions_: number[];

        const symbols_: {
            $accept: number;
            $end: number;
            BOOLEAN: number;
            CLOSE: number;
            CLOSE_BLOCK_PARAMS: number;
            CLOSE_RAW_BLOCK: number;
            CLOSE_SEXPR: number;
            CLOSE_UNESCAPED: number;
            COMMENT: number;
            CONTENT: number;
            DATA: number;
            END_RAW_BLOCK: number;
            EOF: number;
            EQUALS: number;
            ID: number;
            INVERSE: number;
            NULL: number;
            NUMBER: number;
            OPEN: number;
            OPEN_BLOCK: number;
            OPEN_BLOCK_PARAMS: number;
            OPEN_ENDBLOCK: number;
            OPEN_INVERSE: number;
            OPEN_INVERSE_CHAIN: number;
            OPEN_PARTIAL: number;
            OPEN_PARTIAL_BLOCK: number;
            OPEN_RAW_BLOCK: number;
            OPEN_SEXPR: number;
            OPEN_UNESCAPED: number;
            SEP: number;
            STRING: number;
            UNDEFINED: number;
            block: number;
            blockParams: number;
            blockParams_repetition_plus0: number;
            block_option0: number;
            block_option1: number;
            closeBlock: number;
            content: number;
            dataName: number;
            error: number;
            hash: number;
            hashSegment: number;
            hash_repetition_plus0: number;
            helperName: number;
            inverseAndProgram: number;
            inverseChain: number;
            inverseChain_option0: number;
            mustache: number;
            mustache_option0: number;
            mustache_option1: number;
            mustache_repetition0: number;
            mustache_repetition1: number;
            openBlock: number;
            openBlock_option0: number;
            openBlock_option1: number;
            openBlock_repetition0: number;
            openInverse: number;
            openInverseChain: number;
            openInverseChain_option0: number;
            openInverseChain_option1: number;
            openInverseChain_repetition0: number;
            openInverse_option0: number;
            openInverse_option1: number;
            openInverse_repetition0: number;
            openPartialBlock: number;
            openPartialBlock_option0: number;
            openPartialBlock_repetition0: number;
            openRawBlock: number;
            openRawBlock_option0: number;
            openRawBlock_repetition0: number;
            param: number;
            partial: number;
            partialBlock: number;
            partialName: number;
            partial_option0: number;
            partial_repetition0: number;
            path: number;
            pathSegments: number;
            program: number;
            program_repetition0: number;
            rawBlock: number;
            rawBlock_repetition_plus0: number;
            root: number;
            sexpr: number;
            sexpr_option0: number;
            sexpr_repetition0: number;
            statement: number;
        };

        const table: {
            "14": number[];
            "15": number[];
            "19": number[];
            "29": number[];
            "3": number;
            "34": number[];
            "4": number;
            "48": number[];
            "5": number[];
            "51": number[];
            "55": number[];
            "6": number;
            "60": number[];
        }[];

        const terminals_: {
            "14": string;
            "15": string;
            "18": string;
            "19": string;
            "2": string;
            "23": string;
            "29": string;
            "33": string;
            "34": string;
            "39": string;
            "44": string;
            "47": string;
            "48": string;
            "5": string;
            "51": string;
            "54": string;
            "55": string;
            "60": string;
            "65": string;
            "68": string;
            "72": string;
            "73": string;
            "75": string;
            "77": string;
            "80": string;
            "81": string;
            "82": string;
            "83": string;
            "84": string;
            "85": string;
            "87": string;
        };

        const yy: {
        };

        function parse(input: any): any;

        function parseError(str: any, hash: any): void;

        function performAction(yytext: any, yyleng: any, yylineno: any, yy: any, yystate: any, $$: any, _$: any): any;

        function trace(): void;

        namespace Parser {
            // namespace prototype {
            //     // Circular reference from hbs.handlebars.Parser.Parser.prototype
            //     const Parser: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const defaultActions: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const lexer: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const parse: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const parseError: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const performAction: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const productions_: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const symbols_: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const table: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const terminals_: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const trace: any;
            //
            //     // Too-deep object hierarchy from hbs.handlebars.Parser.Parser.prototype
            //     const yy: any;
            //
            // }

        }

        namespace lexer {
            const EOF: number;

            const conditions: {
                INITIAL: {
                    inclusive: boolean;
                    rules: number[];
                };
                com: {
                    inclusive: boolean;
                    rules: number[];
                };
                emu: {
                    inclusive: boolean;
                    rules: number[];
                };
                mu: {
                    inclusive: boolean;
                    rules: number[];
                };
                raw: {
                    inclusive: boolean;
                    rules: number[];
                };
            };

            const options: {
            };

            const rules: RegExp[];

            function begin(condition: any): void;

            function input(): any;

            function less(n: any): void;

            function lex(): any;

            function more(): any;

            function next(): any;

            function parseError(str: any, hash: any): void;

            function pastInput(): any;

            function performAction(yy: any, yy_: any, $avoiding_name_collisions: any, YY_START: any): any;

            function popState(): any;

            function pushState(condition: any): void;

            function setInput(input: any): any;

            function showPosition(): any;

            function topState(): any;

            function unput(ch: any): any;

            function upcomingInput(): any;

            namespace begin {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.begin
                const prototype: any;

            }

            namespace input {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.input
                const prototype: any;

            }

            namespace less {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.less
                const prototype: any;

            }

            namespace lex {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.lex
                const prototype: any;

            }

            namespace more {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.more
                const prototype: any;

            }

            namespace next {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.next
                const prototype: any;

            }

            namespace parseError {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.parseError
                const prototype: any;

            }

            namespace pastInput {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.pastInput
                const prototype: any;

            }

            namespace performAction {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.performAction
                const prototype: any;

            }

            namespace popState {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.popState
                const prototype: any;

            }

            namespace pushState {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.pushState
                const prototype: any;

            }

            namespace setInput {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.setInput
                const prototype: any;

            }

            namespace showPosition {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.showPosition
                const prototype: any;

            }

            namespace topState {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.topState
                const prototype: any;

            }

            namespace unput {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.unput
                const prototype: any;

            }

            namespace upcomingInput {
                // Too-deep object hierarchy from hbs.handlebars.Parser.lexer.upcomingInput
                const prototype: any;

            }

        }

        namespace parse {
            const prototype: {
            };

        }

        namespace parseError {
            const prototype: {
            };

        }

        namespace performAction {
            const prototype: {
            };

        }

        namespace trace {
            const prototype: {
            };

        }

    }

    namespace SafeString {
        // namespace prototype {
        //     function toHTML(): any;
        //
        //     function toString(): any;
        //
        //     namespace toHTML {
        //         // Too-deep object hierarchy from hbs.handlebars.SafeString.prototype.toHTML
        //         const prototype: any;
        //
        //     }
        //
        //     namespace toString {
        //         // Too-deep object hierarchy from hbs.handlebars.SafeString.prototype.toString
        //         const prototype: any;
        //
        //     }
        //
        // }

    }

    namespace Utils {
        function appendContextPath(contextPath: any, id: any): any;

        function blockParams(params: any, ids: any): any;

        function createFrame(object: any): any;

        function escapeExpression(string: any): any;

        function extend(obj: any, ...args: any[]): any;

        function indexOf(array: any, value: any): any;

        function isArray(p0: any): any;

        function isEmpty(value: any): any;

        function isFunction(value: any): any;

        function toString(): any;

        namespace appendContextPath {
            const prototype: {
            };

        }

        namespace blockParams {
            const prototype: {
            };

        }

        namespace createFrame {
            const prototype: {
            };

        }

        namespace escapeExpression {
            const prototype: {
            };

        }

        namespace extend {
            const prototype: {
            };

        }

        namespace indexOf {
            const prototype: {
            };

        }

        namespace isEmpty {
            const prototype: {
            };

        }

        namespace isFunction {
            const prototype: {
            };

        }

    }

    namespace VM {
        function checkRevision(compilerInfo: any): void;

        function invokePartial(partial: any, context: any, options: any): any;

        function noop(): any;

        function resolvePartial(partial: any, context: any, options: any): any;

        function template(templateSpec: any, env: any, ...args: any[]): any;

        function wrapProgram(container: any, i: any, fn: any, data: any, declaredBlockParams: any, blockParams: any, depths: any, ...args: any[]): any;

        namespace checkRevision {
            const prototype: {
            };

        }

        namespace invokePartial {
            const prototype: {
            };

        }

        namespace noop {
            const prototype: {
            };

        }

        namespace resolvePartial {
            const prototype: {
            };

        }

        namespace template {
            const prototype: {
            };

        }

        namespace wrapProgram {
            const prototype: {
            };

        }

    }

    namespace compile {
        const prototype: {
        };

    }

    namespace createFrame {
        const prototype: {
        };

    }

    namespace decorators {
        function inline(fn: any, props: any, container: any, options: any): any;

        namespace inline {
            const prototype: {
            };

        }

    }

    namespace escapeExpression {
        const prototype: {
        };

    }

    namespace helpers {
        function blockHelperMissing(context: any, options: any): any;

        function each(context: any, options: any): any;

        function helperMissing(...args: any[]): any;

        function log(...args: any[]): void;

        function lookup(obj: any, field: any): any;

        function unless(conditional: any, options: any): any;

        namespace blockHelperMissing {
            const prototype: {
            };

        }

        namespace each {
            const prototype: {
            };

        }

        namespace helperMissing {
            const prototype: {
            };

        }

        namespace log {
            const prototype: {
            };

        }

        namespace lookup {
            const prototype: {
            };

        }

        namespace unless {
            const prototype: {
            };

        }

    }

    namespace log {
        const prototype: {
        };

    }

    namespace logger {
        const level: string;

        const methodMap: string[];

        function log(level: any, ...args: any[]): void;

        function lookupLevel(level: any): any;

        namespace log {
            const prototype: {
            };

        }

        namespace lookupLevel {
            const prototype: {
            };

        }

    }

    namespace parse {
        const prototype: {
        };

    }

    namespace precompile {
        const prototype: {
        };

    }

    namespace registerDecorator {
        const prototype: {
        };

    }

    namespace registerHelper {
        const prototype: {
        };

    }

    namespace registerPartial {
        const prototype: {
        };

    }

    namespace template {
        const prototype: {
        };

    }

    namespace unregisterDecorator {
        const prototype: {
        };

    }

    namespace unregisterHelper {
        const prototype: {
        };

    }

    namespace unregisterPartial {
        const prototype: {
        };

    }

}

export namespace localsAsTemplateData {
    const prototype: {
    };

}

export namespace registerAsyncHelper {
    const prototype: {
    };

}

export namespace registerHelper {
    const prototype: {
    };

}

export namespace registerPartial {
    const prototype: {
    };

}

export namespace registerPartials {
    const prototype: {
    };

}

